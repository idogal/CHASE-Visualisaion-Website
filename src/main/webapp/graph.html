<html>
    <head>        
        <script src="sigma/sigma.min.js" type="text/javascript"></script>
        <script src="sigma/plugins/sigma.parsers.gexf.min.js" type="text/javascript"></script>  
        <script src="sigma/plugins/sigma.plugins.filter.min.js" type="text/javascript"></script>  
        <script src="sigma/plugins/sigma.plugins.dragNodes.min.js" type="text/javascript"></script>
        <script src="sigma/plugins/sigma.exporters.svg.min.js" type="text/javascript"></script>
        
        <link href="http://fonts.googleapis.com/css?family=Lato:300,700" rel="stylesheet" type="text/css">
    </head>
    <body>
        <div id="container">
            <style>
                body {
                    color: #333;
                    font-size: 14px;
                    font-family: Lato, sans-serif;
                }
                #graph-container {
                    top: 0;
                    bottom: 0;
                    left: 0;
                    right: 0;
                    position: absolute;
                }
                #credits-box{
                    background-color: rgb(249, 247, 237);
                    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                    bottom: 10px;
                    right: 30px;
                    width: 270px;
                    position: absolute;
                    padding: 5px
                }
                #control-pane {
                    top: 20px;
                    right: 30px;
                    position: absolute;
                    width: 270px;
                    background-color: rgb(249, 247, 237);
                    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                }
                #control-pane > div {
                    margin: 10px;
                    overflow-x: auto;
                }
                .line {
                    clear: both;
                    display: block;
                    width: 100%;
                    margin: 0;
                    padding: 12px 0 0 0;
                    border-bottom: 1px solid #9370DB;
                    background: transparent;
                }
                h2, h3, h4 {
                    padding: 0;
                    font-variant: small-caps;
                }
                .green {
                    color: #437356;
                }
                .purple {
                    color: #9370DB
                }
                h2.underline {
                    color: #9370DB;
                    background: #f4f0e4;
                    margin: 0;
                    border-radius: 2px;
                    padding: 8px 12px;
                    font-weight: 700;
                }
                .hidden {
                    display: none;
                    visibility: hidden;
                }

                input[type=range] {
                    width: 160px;
                }
            </style>
            <div id="graph-container">
                <!-- canvas style="position: absolute; width: 1147px; height: 940px;" class="sigma-scene" width="2294px" height="1880px"></canvas>
                <canvas style="position: absolute; width: 1147px; height: 940px;" class="sigma-labels" width="1147px" height="940px"></canvas>
                <canvas style="position: absolute; width: 1147px; height: 940px;" class="sigma-mouse" width="1147px" height="940px"></canvas-->
            </div>
            <div id="credits-box">
                2017
               <br>
                Powered by: <a href="http://sigmajs.org/">sigma.js</a>
               <br>
                Network parsed by: <a href="http://www.gephi.org/">Gephi</a>
            </div>
            <div id="control-pane">
                <h2 class="underline">The CHASE Authors Community Network</h2>
                <div style="font-size:12px">
                    Click on a node to highlight it's neighbouring nodes. Click on the empty stage area to get back to the default view.
                    <br><br>
                    Network was derived by the <b>Authors Bibliographical Coupling</b> algorithm.
                </div>
                <div>
                    <h3>Author name</h3>
                    <input id="authorName" value="">                    
                    <div>
                        <br>
                        <button id="apply-author-btn">Filter by author</button>
                        <button id="reset-author-btn">Reset author</button>
                    </div>                    
                </div>
                <div>
                    <h3>min degree <span id="min-degree-val">0</span></h3>
                    0 <input id="min-degree" min="0" max="34" value="0" type="range"> <span id="max-degree-value">34</span>
                    <div>
                        <br>
                        <button id="reset-btn">Reset min. degree</button>
                    </div>
                </div>
                <span class="line"></span>
                <div>
                    <button id="export-btn">Export to SVG</button>
                </div>
                <div id="dump" class="hidden"></div>
            </div>
        </div>
        <script>
            /**
             * This is an example on how to use sigma filters plugin on a real-world graph.
             */
            var filter;
            
            /**
             * DOM utility functions
             */
            var utils = {
                $: function (id) {
                    return document.getElementById(id);
                },

                all: function (selectors) {
                    return document.querySelectorAll(selectors);
                },

                /*
                removeClass: function (selectors, cssClass) {
                    var nodes = document.querySelectorAll(selectors);
                    var l = nodes.length;
                    for (i = 0; i < l; i++) {
                        var el = nodes[i];
                        // Bootstrap compatibility
                        el.className = el.className.replace(cssClass, '');
                    }
                },

                addClass: function (selectors, cssClass) {
                    var nodes = document.querySelectorAll(selectors);
                    var l = nodes.length;
                    for (i = 0; i < l; i++) {
                        var el = nodes[i];
                        // Bootstrap compatibility
                        if (-1 == el.className.indexOf(cssClass)) {
                            el.className += ' ' + cssClass;
                        }
                    }
                },*/

                show: function (selectors) {
                    this.removeClass(selectors, 'hidden');
                },

                hide: function (selectors) {
                    this.addClass(selectors, 'hidden');
                },

                toggle: function (selectors, cssClass) {
                    var cssClass = cssClass || "hidden";
                    var nodes = document.querySelectorAll(selectors);
                    var l = nodes.length;
                    for (i = 0; i < l; i++) {
                        var el = nodes[i];
                        //el.style.display = (el.style.display != 'none' ? 'none' : '' );
                        // Bootstrap compatibility
                        if (-1 !== el.className.indexOf(cssClass)) {
                            el.className = el.className.replace(cssClass, '');
                        } else {
                            el.className += ' ' + cssClass;
                        }
                    }
                }
            };
            
            // Add a method to the graph model that returns an
            // object with every neighbors of a node inside:
            sigma.classes.graph.addMethod('neighbors', function (nodeId) {
                var k,
                        neighbors = {},
                        index = this.allNeighborsIndex[nodeId] || {};

                for (k in index)
                    neighbors[k] = this.nodesIndex[k];

                return neighbors;
            });

            function updatePane(graph, filter) {
                // get max degree
                var maxDegree = 0,
                        categories = {};

                // read nodes
                graph.nodes().forEach(function (n) {
                    maxDegree = Math.max(maxDegree, graph.degree(n.id));
                    categories[n.attributes.acategory] = true;
                });

                // min degree
                utils.$('min-degree').max = maxDegree;
                utils.$('max-degree-value').textContent = maxDegree;

                /*
                 // node category
                 var nodecategoryElt = utils.$('node-category');
                 Object.keys(categories).forEach(function (c) {
                 var optionElt = document.createElement("option");
                 optionElt.text = c;
                 nodecategoryElt.add(optionElt);
                 });*/

                // reset button
                utils.$('reset-btn').addEventListener("click", function (e) {
                    utils.$('min-degree').value = 0;
                    utils.$('min-degree-val').textContent = '0';
                    //utils.$('node-category').selectedIndex = 0;
                    filter.undo().apply();
                    utils.$('dump').textContent = '';
                    utils.hide('#dump');
                });
            }
            
            sigma.parsers.gexf(
                    'data/abc.gexf',
                    {
                        renderer: {
                          container: 'graph-container',
                          type: 'canvas'
                        },
                        settings: {
                          edgeLabelSize: 'proportional',
                          minArrowSize: '7',
                          defaultEdgeType: 'curvedArrow',
                          hoverFontStyle: 'bold',
                          labelThreshold: 4,
                          defaultLabelSize: 14
                        }
                    },
                    function (s) {        
                        filter = new sigma.plugins.filter(s);
                        updatePane(s.graph, filter);     
                        
                        // Initialize the dragNodes plugin:
                        var dragListener = sigma.plugins.dragNodes(s, s.renderers[0]);

                        dragListener.bind('startdrag', function(event) {
                          console.log(event);
                        });
                        dragListener.bind('drag', function(event) {
                          console.log(event);
                        });
                        dragListener.bind('drop', function(event) {
                          console.log(event);
                        });
                        dragListener.bind('dragend', function(event) {
                          console.log(event);
                        });                           

                        // We first need to save the original colors of our
                        // nodes and edges, like this:
                        s.graph.nodes().forEach(function (n) {
                            n.originalColor = n.color;
                        });
                        s.graph.edges().forEach(function (e) {
                            e.originalColor = e.color;
                        });
                        
                        s.bind('clickNode', function (e) {
                            var nodeId = e.data.node.id;
                            highlightNeighbours(e, nodeId);
                        });
                        
                        s.bind('clickStage', function () {
                            resetGraph();
                        });
                        
                        function applyMinDegreeFilter(e) {
                            var v = e.target.value;
                            utils.$('min-degree-val').textContent = v;

                            filter
                                    .undo('min-degree')
                                    .nodesBy(function (n) {
                                        return this.degree(n.id) >= v;
                                    }, 'min-degree')
                                    .apply();
                        }

                        function highlightNeighbours(e, nodeId) {
                            var toKeep = s.graph.neighbors(nodeId);
                            if (e.type === "clickNode")
                                toKeep[nodeId] = e.data.node;

                            s.graph.nodes().forEach(function (n) {
                                if (toKeep[n.id])
                                    n.color = n.originalColor;
                                else
                                    n.color = '#eee';
                            });

                            s.graph.edges().forEach(function (e) {
                                if (toKeep[e.source] && toKeep[e.target])
                                    e.color = e.originalColor;
                                else
                                    e.color = '#eee';
                            });
                            
                            s.refresh();
                        }

                        function getInputAuthorNode(authorName) {
                            var returnNode;

                            s.graph.nodes().forEach(function (node) {
                                var nodeLabel = node.label;
                                if (authorName === nodeLabel) {
                                    returnNode = node;
                                }
                            });

                            return returnNode;
                        }

                        function filterByAuthor(e) {
                            var inputAuthourName = document.getElementById("authorName").value;
                            var inputAuthorNode = getInputAuthorNode(inputAuthourName);

                            if (typeof inputAuthorNode !== 'undefined') {
                                var inputAuthorNodeID = inputAuthorNode.id;
                                highlightNeighbours(e, inputAuthorNodeID);

                                s.graph.nodes().forEach(function (n) {
                                    if (inputAuthorNodeID === n.id) {
                                        n.color = n.originalColor;
                                    }
                                });

                                s.graph.edges().forEach(function (e) {
                                    if ((e.source === inputAuthorNode.id || e.target === inputAuthorNode.id)) {
                                        e.color = e.originalColor;
                                    }
                                });

                                s.refresh();
                            }
                        }

                        function resetAuthorFilter() {
                            //document.getElementsByName("authorName").value = "";
                            resetGraph();
                        }
                        
                        function resetGraph() {
                            s.graph.nodes().forEach(function (n) {
                                n.color = n.originalColor;
                            });

                            s.graph.edges().forEach(function (e) {
                                e.color = e.originalColor;
                            });

                            // Same as in the previous event:
                            s.refresh();
                        }

                        function exportGraph () {
                            console.log('exporting...');
                            var output = s.toSVG(
                            {   download: true
                              , filename: 'CHASE_Authors_BC_Graph.svg'
                              , size: 1000
                              , labels: true
                            });
                            console.log(output);
                        };

                        utils.$('min-degree').addEventListener("input", applyMinDegreeFilter);  // for Chrome and FF
                        utils.$('min-degree').addEventListener("change", applyMinDegreeFilter); // for IE10+, that sucks
                        utils.$('reset-author-btn').addEventListener("click", resetAuthorFilter);
                        utils.$('apply-author-btn').addEventListener("click", filterByAuthor);
                        utils.$('export-btn').addEventListener("click", exportGraph);
                    }
            );
        </script>
    </body>
</html>